"""
Core components for the execution simulation engine.
"""
from datetime import date
from typing import Dict, List, Literal, Tuple

import pandas as pd
from pydantic import BaseModel, Field

from src.config import ExecutionConfig

__all__ = ["Signal", "Fill", "UnfilledSignal", "simulate_execution"]


class Signal(BaseModel):
    """Represents a trading signal generated by a detector."""

    symbol: str = Field(..., description="The stock symbol.")
    signal_date: date = Field(..., description="The date the signal was generated.")
    action: Literal["BUY", "SELL"] = Field(..., description="The trading action.")
    source: str = Field(..., description="The name of the detector that generated the signal.")


class Fill(BaseModel):
    """Represents a successfully executed trade."""

    signal: Signal = Field(..., description="The signal that resulted in this fill.")
    executed_date: date = Field(..., description="The date the trade was executed.")
    executed_price: float = Field(..., description="The price at which the trade was executed, including slippage.")
    fees: float = Field(..., description="The transaction fees for the trade.")


class UnfilledSignal(BaseModel):
    """Represents a signal that could not be executed."""

    signal: Signal = Field(..., description="The signal that failed to execute.")
    reason: str = Field(..., description="The reason the signal was not filled.")
    attempted_date: date = Field(..., description="The date the execution was attempted.")


def simulate_execution(
    signals: List[Signal],
    data: Dict[str, pd.DataFrame],
    config: ExecutionConfig,
) -> Tuple[List[Fill], List[UnfilledSignal]]:
    """
    Simulates trade execution based on signals, market data, and execution rules.

    Args:
        signals: A list of trading signals to be executed.
        data: A dictionary mapping symbols to their historical price data.
        config: The execution configuration with rules for slippage, fees, etc.

    Returns:
        A tuple containing two lists: one of successfully filled trades
        and one of signals that could not be filled.
    """
    fills: List[Fill] = []
    unfilled: List[UnfilledSignal] = []

    for signal in signals:
        symbol_data = data.get(signal.symbol)
        if symbol_data is None or symbol_data.empty:
            unfilled.append(
                UnfilledSignal(
                    signal=signal,
                    reason=f"No data for symbol {signal.symbol}",
                    attempted_date=signal.signal_date,
                )
            )
            continue

        # Find the index for the signal date and the execution date (next trading day)
        try:
            # Ensure the index is sorted for efficient lookup
            if not symbol_data.index.is_monotonic_increasing:
                symbol_data = symbol_data.sort_index()

            signal_date_loc = symbol_data.index.get_loc(pd.Timestamp(signal.signal_date))
        except KeyError:
            unfilled.append(
                UnfilledSignal(
                    signal=signal,
                    reason=f"Signal date {signal.signal_date} not found in data",
                    attempted_date=signal.signal_date,
                )
            )
            continue

        if signal_date_loc + 1 >= len(symbol_data):
            unfilled.append(
                UnfilledSignal(
                    signal=signal,
                    reason="Signal is on the last day of available data",
                    attempted_date=signal.signal_date,
                )
            )
            continue

        execution_loc = signal_date_loc + 1
        prev_close = symbol_data.iloc[signal_date_loc]["Close"]
        exec_open = symbol_data.iloc[execution_loc]["Open"]
        exec_date = symbol_data.index[execution_loc].date()

        # 1. Circuit Guard
        price_change_pct = (exec_open - prev_close) / prev_close
        if abs(price_change_pct) > config.circuit_guard_pct:
            unfilled.append(
                UnfilledSignal(
                    signal=signal,
                    reason=f"Circuit guard triggered: {price_change_pct:.2%} change",
                    attempted_date=exec_date,
                )
            )
            continue

        # 2. Slippage
        # NOTE: Slippage model values are assumed to be in basis points (bps).
        gap_pct = abs(price_change_pct)
        slippage_bps = 0.0
        if gap_pct <= 0.02:
            slippage_bps = config.slippage_model.get("gap_2pct", 0.0)
        elif gap_pct <= 0.05:
            slippage_bps = config.slippage_model.get("gap_5pct", 0.0)
        else:
            slippage_bps = config.slippage_model.get("gap_high", 0.0)

        slippage_amount = exec_open * (slippage_bps / 10000.0)

        if signal.action == "BUY":
            executed_price = exec_open + slippage_amount
        else:  # SELL
            executed_price = exec_open - slippage_amount

        # 3. Fees
        fees = executed_price * (config.fees_bps / 10000.0)

        fills.append(
            Fill(
                signal=signal,
                executed_date=exec_date,
                executed_price=executed_price,
                fees=fees,
            )
        )

    return fills, unfilled
